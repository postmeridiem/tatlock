#!/usr/bin/env python3
"""
Comprehensive benchmark script for all hardware performance tiers.
Tests Phase 1 (simple queries) and Phase 2 (tool-assisted queries) for each tier.
"""

import time
import json
import csv
import requests
from datetime import datetime
import subprocess
import sys
import os

# Test configurations for each tier
HARDWARE_TIERS = {
    "low": {
        "model": "phi4-mini:3.8b-q4_K_M",
        "tier": "low",
        "description": "Quantized model with tool support"
    },
    "medium": {
        "model": "mistral:7b",
        "tier": "medium",
        "description": "Balanced performance, Apple Silicon optimized"
    },
    "high": {
        "model": "gemma3-cortex:latest",
        "tier": "high",
        "description": "Maximum performance for high-spec systems"
    }
}

# Test queries
PHASE_1_QUERIES = [
    "What is 2+2?",
    "Explain quantum computing in one sentence.",
    "What is the capital of France?",
    "Name three programming languages.",
    "What is artificial intelligence?"
]

PHASE_2_QUERIES = [
    "What did we discuss before?",
    "Find my personal information about hobbies",
    "What memories do you have about our previous conversations?",
    "Recall any information about my preferences",
    "Search for topics we've talked about"
]

BASE_URL = "http://localhost:8000"
COOKIES_FILE = "cookies.txt"

def login_and_get_session():
    """Login to get a valid session cookie."""
    login_data = {
        "username": "admin",
        "password": "breaker"
    }

    try:
        response = requests.post(
            f"{BASE_URL}/login/auth",
            data=login_data,
            timeout=30
        )

        if response.status_code == 200:
            # Extract session cookie
            session_cookie = None
            for cookie in response.cookies:
                if cookie.name == 'session':
                    session_cookie = cookie.value
                    break

            if session_cookie:
                # Save to cookies file
                with open(COOKIES_FILE, 'w') as f:
                    f.write("# Netscape HTTP Cookie File\n")
                    f.write("# https://curl.se/docs/http-cookies.html\n")
                    f.write("# This file was generated by libcurl! Edit at your own risk.\n\n")
                    f.write(f"#HttpOnly_localhost\tFALSE\t/\tFALSE\t{int(time.time()) + 3600}\tsession\t{session_cookie}\n")

                print("‚úÖ Login successful, session cookie saved")
                return True
            else:
                print("‚ùå No session cookie in login response")
                return False
        else:
            print(f"‚ùå Login failed: {response.status_code}")
            return False
    except Exception as e:
        print(f"‚ùå Login error: {e}")
        return False

def set_hardware_tier(tier_name):
    """Set the hardware configuration to use a specific tier."""
    tier_config = HARDWARE_TIERS[tier_name]

    config_content = f'''"""
Hardware Configuration for Tatlock
Generated automatically during installation - do not edit manually.
This file contains pre-computed hardware classification to avoid
runtime hardware detection overhead.
"""

# Hardware classification results
RECOMMENDED_MODEL = "{tier_config["model"]}"
PERFORMANCE_TIER = "{tier_config["tier"]}"
HARDWARE_REASON = "BENCHMARK: Testing {tier_name} tier - {tier_config["description"]}"

# Hardware details (for reference)
HARDWARE_SUMMARY = '{{"tier": "{tier_name}", "model": "{tier_config["model"]}", "benchmark": true}}'
'''

    with open('hardware_config.py', 'w') as f:
        f.write(config_content)

    print(f"‚úÖ Hardware config set to {tier_name} tier ({tier_config['model']})")

def restart_server():
    """Restart the server to pick up new hardware configuration."""
    print("üîÑ Restarting server...")

    # Kill existing server processes
    try:
        subprocess.run(["pkill", "-f", "python.*main.py"], capture_output=True)
        time.sleep(3)
    except:
        pass

    # Start new server in background
    env = os.environ.copy()
    env["PYTHONPATH"] = os.getcwd()
    process = subprocess.Popen(
        ["python", "main.py"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=env,
        cwd=os.getcwd()
    )

    # Wait for server to start
    time.sleep(10)

    # Login to get new session
    max_retries = 5
    for attempt in range(max_retries):
        if login_and_get_session():
            break
        print(f"üîÑ Login attempt {attempt + 1} failed, retrying in 2 seconds...")
        time.sleep(2)
    else:
        print("‚ùå Failed to login after server restart")
        return None

    print("‚úÖ Server restarted and authenticated")
    return process

def test_query(query, query_type, attempt=1):
    """Test a single query and measure response time."""
    headers = {
        'Content-Type': 'application/json'
    }

    # Read cookies
    cookies = {}
    try:
        with open(COOKIES_FILE, 'r') as f:
            for line in f:
                if line.startswith('#HttpOnly_localhost'):
                    parts = line.strip().split('\t')
                    if len(parts) >= 7:
                        cookies['session'] = parts[6]
                        break
    except FileNotFoundError:
        print("‚ùå Cookies file not found")
        return None

    data = {
        "message": query,
        "history": [],
        "conversation_id": f"benchmark-{query_type}-{int(time.time())}"
    }

    try:
        start_time = time.time()
        response = requests.post(
            f"{BASE_URL}/cortex",
            headers=headers,
            cookies=cookies,
            json=data,
            timeout=120
        )
        end_time = time.time()

        if response.status_code == 200:
            response_data = response.json()
            api_response = response_data.get("response", "")
            return {
                "success": True,
                "response_time": round(end_time - start_time, 3),
                "response_length": len(api_response),
                "response_content": api_response,
                "status_code": response.status_code,
                "query": query,
                "query_type": query_type
            }
        else:
            print(f"‚ùå Error {response.status_code}: {response.text}")
            return {
                "success": False,
                "response_time": 0,
                "error": f"HTTP {response.status_code}",
                "query": query,
                "query_type": query_type
            }
    except Exception as e:
        print(f"‚ùå Request failed: {e}")
        return {
            "success": False,
            "response_time": 0,
            "error": str(e),
            "query": query,
            "query_type": query_type
        }

def benchmark_tier(tier_name, results_filename="benchmark_results.csv"):
    """Benchmark a specific hardware tier with all test queries."""
    print(f"\nüß™ Testing {tier_name.upper()} tier ({HARDWARE_TIERS[tier_name]['model']})")

    # Set hardware configuration
    set_hardware_tier(tier_name)

    # Restart server
    server_process = restart_server()
    if server_process is None:
        print(f"‚ùå Failed to restart server for {tier_name} tier")
        return []

    results = []

    try:
        # Test Phase 1 queries (simple responses)
        print("üìã Testing Phase 1 queries (simple responses)...")
        for i, query in enumerate(PHASE_1_QUERIES, 1):
            print(f"  {i}/{len(PHASE_1_QUERIES)}: {query[:50]}...")
            result = test_query(query, "phase1")
            if result:
                result.update({
                    "tier": tier_name,
                    "model": HARDWARE_TIERS[tier_name]["model"],
                    "phase": "1",
                    "timestamp": datetime.now().isoformat()
                })
                results.append(result)
                # Save result incrementally
                append_result_to_csv(result, results_filename)
                print(f"    ‚úÖ {result['response_time']}s")
            else:
                print("    ‚ùå Failed")

        # Test Phase 2 queries (tool-assisted)
        print("üîß Testing Phase 2 queries (tool-assisted)...")
        for i, query in enumerate(PHASE_2_QUERIES, 1):
            print(f"  {i}/{len(PHASE_2_QUERIES)}: {query[:50]}...")
            result = test_query(query, "phase2")
            if result:
                result.update({
                    "tier": tier_name,
                    "model": HARDWARE_TIERS[tier_name]["model"],
                    "phase": "2",
                    "timestamp": datetime.now().isoformat()
                })
                results.append(result)
                # Save result incrementally
                append_result_to_csv(result, results_filename)
                print(f"    ‚úÖ {result['response_time']}s")
            else:
                print("    ‚ùå Failed")

    finally:
        # Clean up server process
        try:
            server_process.terminate()
            server_process.wait(timeout=5)
        except:
            server_process.kill()

    return results

def save_results_to_csv(all_results, filename="benchmark_results.csv"):
    """Save all benchmark results to a CSV file."""
    if not all_results:
        print("‚ùå No results to save")
        return

    fieldnames = [
        "timestamp", "tier", "model", "phase", "query_type", "query",
        "success", "response_time", "response_length", "response_content", "error"
    ]

    with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        for result in all_results:
            # Ensure all required fields are present
            row = {field: result.get(field, "") for field in fieldnames}
            writer.writerow(row)

    print(f"‚úÖ Results saved to {filename}")

def append_result_to_csv(result, filename="benchmark_results.csv"):
    """Append a single result to the CSV file incrementally."""
    fieldnames = [
        "timestamp", "tier", "model", "phase", "query_type", "query",
        "success", "response_time", "response_length", "response_content", "error"
    ]

    # Check if file exists to determine if we need to write headers
    file_exists = os.path.exists(filename)

    with open(filename, 'a', newline='', encoding='utf-8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        # Write header if file is new
        if not file_exists:
            writer.writeheader()

        # Ensure all required fields are present
        row = {field: result.get(field, "") for field in fieldnames}
        writer.writerow(row)

    print(f"üìù Result appended to {filename}")

def analyze_results(all_results):
    """Analyze and print summary statistics."""
    print("\nüìä BENCHMARK RESULTS SUMMARY")
    print("=" * 60)

    by_tier = {}
    for result in all_results:
        if not result.get("success"):
            continue

        tier = result["tier"]
        phase = result["phase"]
        key = f"{tier}_phase{phase}"

        if key not in by_tier:
            by_tier[key] = []
        by_tier[key].append(result["response_time"])

    for key, times in by_tier.items():
        tier_phase = key.replace("_", " ")
        avg_time = sum(times) / len(times)
        min_time = min(times)
        max_time = max(times)

        print(f"{tier_phase.upper():<20} | Avg: {avg_time:6.2f}s | Min: {min_time:6.2f}s | Max: {max_time:6.2f}s | Tests: {len(times)}")

def main():
    """Run comprehensive benchmarks for all hardware tiers."""
    print("üöÄ Starting Comprehensive Hardware Tier Benchmarks")
    print("=" * 60)

    # Create timestamped filename for incremental results
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    results_filename = f"benchmark_results_{timestamp}.csv"

    all_results = []

    # Test each tier
    for tier_name in ["low", "medium", "high"]:
        try:
            tier_results = benchmark_tier(tier_name, results_filename)
            all_results.extend(tier_results)
        except KeyboardInterrupt:
            print("\n‚ö†Ô∏è Benchmark interrupted by user")
            break
        except Exception as e:
            print(f"‚ùå Error testing {tier_name} tier: {e}")

    # Analyze results if we have any
    if all_results:
        analyze_results(all_results)
        print(f"\nüìä Complete results saved to: {results_filename}")
    else:
        print("\n‚ùå No results collected")

    print("\n‚úÖ Benchmark complete!")

if __name__ == "__main__":
    main()